# Create the Inngest Client

The `Inngest` client object is used to configure your application, enabling you to create functions and send events.

```ts
import { Inngest } from "inngest";

const inngest = new Inngest({
  name: "My application",
});
```

---

## Configuration

<Properties>
  <Property name="name" type="string" required>
    The unique name of your application.
  </Property>
  <Property name="eventKey" type="string">
    An Inngest [Event Key](/docs/events/creating-an-event-key). Alternatively, set the `INNGEST_EVENT_KEY` environment variable.
  </Property>
  <Property name="schemas" type="EventSchemas" version="v2.0.0+">
    Event payload types. See [Defining Event Payload Types](#defining-event-payload-types).
  </Property>
  <Property name="logger" type="Logger" version="v2.0.0+">
    A logger object that provides the following interfaces (`.info()`, `.warn()`, `.error()`, `.debug()`). Defaults to using `console` if not provided. See [logging guide](/docs/guides/logging) for more details.
  </Property>
  <Property name="middleware" type="array" version="v2.0.0+">
    A stack of [middleware](/docs/reference/middleware/overview) to add to the client.
  </Property>
  <Property name="env" type="string">
    The environment name. Required only when using [Branch Environments](/docs/platform/environments).
  </Property>
  <Property name="fetch" type="Fetch API compatible interface">
    Override the default [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) implementation. Defaults to the runtime's native Fetch API.
  </Property>
  <Property name="inngestBaseUrl" type="string">
    Override the default (`https://inn.gs/`) base URL for sending events.
  </Property>
</Properties>

<Callout>
We recommend setting the `INNGEST_EVENT_KEY` as an environment variable over using the `eventKey` option. As with any secret, it's not a good practice to hard-code the event key in your codebase.
</Callout>

## Defining Event Payload Types

You can leverage TypeScript to define your event payload types. When you pass types to the Inngest client, events are fully typed when using them with `inngest.send()` and `inngest.createFunction()`. This can more easily alert you to issues with your code during compile time.

<Callout>
Click the toggles on the top left of the code block to see the different methods available!
</Callout>

<CodeGroup forceTabs={true}>
```ts {{ title: "Union (v2)" }}
import { EventSchemas, Inngest } from "inngest";

type AppAccountCreated = {
  name: "app/account.created";
  data: {
    userId: string;
  };
};

type AppSubscriptionStarted = {
  name: "app/subscription.started";
  data: {
    userId: string;
    planId: string;
  };
};

type Events = AppAccountCreated | AppSubscriptionStarted;

export const inngest = new Inngest({
  name: "My App",
  schemas: new EventSchemas().fromUnion<Events>(),
});
```
```ts {{ title: "Record (v2)"}}
import { EventSchemas, Inngest } from "inngest";

type Events = {
  "app/account.created": {
    data: {
      userId: string;
    };
  };
  "app/subscription.started": {
    data: {
      userId: string;
      planId: string;
    };
  };
};

export const inngest = new Inngest({
  name: "My App",
  schemas: new EventSchemas().fromRecord<Events>(),
});
```
```ts {{ title: "Zod (v2)" }}
import { EventSchemas, Inngest } from "inngest";
import { z } from "zod";

const events = {
  "app/account.created": {
    data: z.object({
      userId: z.string(),
    }),
  },
  "app/subscription.started": {
    data: z.object({
      userId: z.string(),
      planId: z.string(),
    }),
  },
};

export const inngest = new Inngest({
  name: "My App",
  schemas: new EventSchemas().fromZod(events),
});
```
```ts {{ title: "Stacking (v2)" }}
import { EventSchemas, Inngest } from "inngest";
import { z } from "zod";

type Events = {
  "app/user.created": {
    data: { id: string };
  };
};

const zodEventSchemas = {
  "app/account.created": {
    data: z.object({
      userId: z.string(),
    }),
  },
};

type AppPostCreated = {
  name: "app/post.created";
  data: { id: string };
};

type AppPostDeleted = {
  name: "app/post.deleted";
  data: { id: string };
};

export const inngest = new Inngest({
  name: "My App",
  schemas: new EventSchemas()
    .fromRecord<Events>()
    .fromUnion<AppPostCreated | AppPostDeleted>()
    .fromZod(zodEventSchemas),
});
```
```ts {{ title: "v1" }}
type Events = {
  "app/account.created": {
    name: "app/account.created";
    data: {
      userId: string;
    };
  };
  "app/subscription.started": {
    name: "app/subscription.started";
    data: {
      userId: string;
      planId: string;
    };
  };
};

export const inngest = new Inngest<Events>({ name: "My App" });
```
</CodeGroup>

### Reusing event types <VersionBadge version="v2.0.0+" />

You can use the `GetEvents<>` generic to access the final event types from an Inngest client.

<Callout>
It's recommended to use this instead of directly reusing your event types, as Inngest will add extra properties and internal events such as `ts` and `inngest/function.failed`.
</Callout>

```ts
import { EventSchemas, Inngest, type GetEvents } from "inngest";

export const inngest = new Inngest({
  name: "Example App",
  schemas: new EventSchemas().fromRecord<{
    "app/user.created": { data: { userId: string } };
  }>(),
});

type Events = GetEvents<typeof inngest>;
type AppUserCreated = Events["app/user.created"];
```

## Best Practices

### Share your client across your codebase

Instantiating the `Inngest` client in a single file and sharing it across your codebase is ideal as you only need a single place to configure your client and define types which can be leveraged anywhere you send events or create functions.

```ts  {{ filename: './inngest/client.ts' }}
import { Inngest } from "inngest";

export const inngest = new Inngest({ name: "My App" });
```

```ts  {{ filename: './inngest/myFunction.ts' }}
import { inngest } from "./client";

export default inngest.createFunction(...);
```
