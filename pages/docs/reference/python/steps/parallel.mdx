# Parallel <VersionBadge version="v0.3.0+" />

Run steps in parallel. Returns the parallel steps' result as a tuple.

## Arguments

<Properties>
  <Property name="callables" type="tuple[Callable[[], object], ...]" required>
    Accepts a tuple of callables. Each callable has no arguments and returns a JSON serializable value. Typically this is just a `lambda` around a `step` method.
  </Property>
</Properties>

## Examples

```py
@inngest_client.create_function(
    fn_id="my-function",
    trigger=inngest.TriggerEvent(event="app/my-function"),
)
async def fn(
    ctx: inngest.Context,
    step: inngest.Step,
) -> None:
    def _step_1a() -> int:
        return 1

    def _step_1b() -> int:
        return 2

    (step_1_res, step_2_res) = await step.parallel(
        (
            lambda: step.run("1a", _step_1a),
            lambda: step.run("1b", _step_1b),
        )
    )
```

## Frequently asked questions

### Do parallel steps work if I don't use `async` functions?

Yes, parallel steps work with both `async` and non-`async` functions. Since our execution model uses a separate HTTP request for each step, threaded HTTP frameworks (e.g. Flask) will create a separate thread for each step.

### Can I use `asyncio.gather` instead of `step.parallel`?

No, `asyncio.gather` will not work as expected. Our execution model necessitates a control flow interruption when we encounter a `step` method, but we don't currently have a way to make that work with `asyncio.gather`.

### Why does `step.parallel` accept a tuple instead of variadic arguments?

To properly type-annotate `step.parallel` we need to statically "extract" the return types of the callables. Python's type-checkers are better at doing this with tuples than with variadic arguments. Mypy still struggles even with tuples, but Pyright is able to properly infer the `step.parallel` return type.
