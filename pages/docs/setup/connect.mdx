import { Info, Warning, CodeGroup, Steps, Step } from "shared/Docs/mdx";

# Connect

<Info>
  These docs are part of a developer preview for Inngest's `connect` API. This feature must be enabled on your account by contacting support.
</Info>

The `connect` API allows your app to create an outbound persistent connection to Inngest. Each app can establish multiple connections to Inngest, which enable you to scale horizontally across multiple workers. The key benefits of using `connect` compared to [`serve`](/docs/learn/serving-inngest-functions) are:

- **Lowest latency** - Persistent connections enable the lowest latency between your app and Inngest.
- **Elastic horizontal scaling** - Easily add more capacity by running additional workers.
- **Ideal for container runtimes** -  Deploy on Kubernetes or ECS without the need of a load balancer for inbound traffic
- **Simpler long running steps** - Step execution is not bound by platform http timeouts.

## Getting started

Using `connect` with your app is simple. Using each SDK's "connect" method only requires a list of functions that are available to be executed. (NOTE - Python is not yet supported)

Here is a one-file example of a fully-functioning app that connects to Inngest.

<CodeGroup>
```ts
import { Inngest } from 'inngest'

const inngest = new Inngest({
  id: 'my-app'
});

const handleSignupFunction = inngest.createFunction(
  { id: 'handle-signup' },
  { event: 'user.created'}
  async ({ event, step }) => {
    console.log('Function called', event);
  }
);

inngest.connect({
  functions: [handleSignupFunction],
}).then((connection) => {
  console.log('Worker: connected', connection);
});
```
```go
type UserCreatedEvent struct {
	Name string
	Data struct {
		UserID string `json:"user_id"`
	}
}

func main() {
	ctx := context.Background()

	app := inngestgo.NewHandler("my-app", inngestgo.HandlerOpts{
		Logger:  logger.StdlibLogger(ctx),
	})

	f := inngestgo.CreateFunction(
		inngestgo.FunctionOpts{ID: "handle-signup", Name: "Handle signup"},
		inngestgo.EventTrigger("user.created", nil),
		func(ctx context.Context, input inngestgo.Input[UserCreatedEvent]) (any, error) {
      fmt.Println("Function called")
			return map[string]any{"success": true}, nil
		},
	)

	app.Register(f)

	fmt.Println("Worker: connecting")

	err := app.Connect(ctx)
	if err != nil {
		fmt.Printf("ERROR: %#v\n", err)
		os.Exit(1)
	}
}
```
</CodeGroup>

## How does it work?

The `connect` API establishes a persistent WebSocket connection to Inngest. Each connection can handle executing multiple functions and steps concurrently. Each app can create multiple connections to Inngest enabling horizontal scaling. Additionally, connect has the following features:

- **Automatic re-connections** - The connection will automatically reconnect if it is closed.
- **Graceful shutdown** - The connection will gracefully shutdown when the app receives a signal to terminate (`SIGTERM`). New steps will not be accepted after the connection is closed, and existing steps will be allowed to complete.
- **Worker-level maximum concurrency** - Each worker can configure the maximum number of concurrent steps it can handle. This allows Inngest to distribute load across multiple workers and not overload a single worker.

## Deploying to production

<Steps>
  <Step title="Set signing and event keys">
    To enable your application to securely connect to Inngest, you must set the `INNGEST_SIGNING_KEY` and `INNGEST_EVENT_KEY` environment variables.

    These keys can be found in the Inngest Dashboard. Learn more about [Event keys](/docs/events/creating-an-event-key) and [Signing Keys](/docs/platform/signing-keys).
  </Step>
  <Step title="Set your app version">
    The `appVersion` is used to identify the version of your app that is connected to Inngest. This allows Inngest to support rolling deploys where multiple versions of your app may be connected to Inngest.

    When a new version of your app is connected to Inngest, the functions' configurations are synced to Inngest. When a new version is connected, Inngest update the function configuration in your environment and starts routing new function runs to the latest version.

    You can set the `appVersion` to whatever you want, but we recommend using something that automatically changes with each deploy, like a git commit sha or Docker image tag.

    <CodeGroup>
    ```ts {{ title: "GitHub Actions" }}
    // If you're using Github Actions to build your app, you can set the
    // app version to the GITHUB_SHA environment variable.
    const inngest = new Inngest({
      id: 'my-app',
      appVersion: process.env.GITHUB_SHA,
    })
    ```
    ```ts {{ title: "Render" }}
    // Render includes the RENDER_GIT_COMMIT env var at build and runtime.
    // https://render.com/docs/environment-variables
    const inngest = new Inngest({
      id: 'my-app',
      appVersion: process.env.RENDER_GIT_COMMIT,
    })
    ```
    ```ts { {title: "Fly.io" }}
    // Fly includes a machine version env var at runtime.
    // https://fly.io/docs/machines/runtime-environment/
    const inngest = new Inngest({
      id: 'my-app',
      appVersion: process.env.FLY_MACHINE_VERSION,
    })
    ```
    </CodeGroup>
  </Step>
  <Step title="Set the instance id (recommended)">
    The `instanceId` is used to identify the worker instance of your app that is connected to Inngest. This allows Inngest to support multiple instances (workers) of your app connected to Inngest.

    By default, Inngest will attempt to use the hostname of the worker as the instance id. If you're running your app in a containerized environment, you can set the `instanceId` to the container id.

    <CodeGroup>
    ```ts {{ title: "Render" }}
    // Render includes the RENDER_INSTANCE_ID env var at runtime.
    // https://render.com/docs/environment-variables
    connect({
      functions: [...],
      instanceId: process.env.RENDER_INSTANCE_ID,
    })
    ```
    ```ts {{ title: "Fly.io" }}
    // Fly includes the FLY_MACHINE_ID env var at runtime.
    // https://fly.io/docs/machines/runtime-environment/
    connect({
      functions: [...],
      instanceId: process.env.FLY_MACHINE_ID,
    })
    ```
    </CodeGroup>
  </Step>
  <Step title="Set the max concurrency (recommended)">
    The `maxConcurrency` option is used to limit the number of concurrent steps that can be executed by the worker instance. This allows Inngest to distribute load across multiple workers and not overload a single worker.

    <Warning>
      The `maxConcurrency` option is not yet supported.
    </Warning>

    <CodeGroup>
    ```ts
    connect({
      functions: [...],
      maxConcurrency: 100,
    })
    ```
    </CodeGroup>
  </Step>
</Steps>

## Kubernetes

_Kubernetes guide and best practices coming soon_
