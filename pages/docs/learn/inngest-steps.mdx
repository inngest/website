import IconConcurrency from 'src/shared/Icons/FlowControl/Concurrency';

export const description = 'Learn what Inngest functions are and of what they are capable.';

# Inngest Steps

Steps are fundamental building blocks in Inngest functions. Each step represents individual task (or other unit of work) within a function that can be executed independently. They are crucial because they allow functions to run specific tasks in a controlled and sequential (or parallel) manner. You can build complex workflows by chaining together simple, discrete operations.

## Benefits of Steps

- Error Isolation: By breaking down functions into smaller steps, errors can be isolated and handled more effectively, minimizing the impact on the overall workflow.
- Independent Testing: Each step can be independently tested and debugged, ensuring more robust and reliable applications.
- Retry Mechanism: Failing steps can be retried and recovered without re-executing already successful steps.
- Improved Reliability: Structured steps enhance the overall reliability of applications by allowing precise control and handling of each task within a function.
- Enhanced Error Handling: Capturing and managing errors at the step level leads to better error recovery and resilience in applications.

By breaking down a function into smaller, manageable steps, errors can be isolated and handled more effectively, which minimizes the impact on the overall workflow. This means that each failing step captures any error or exception and can be independently tested, debugged, retried, and recovered. It also will not be re-executed if it has already been successfully executed, even when another steps failed.

If you'd like to learn more about how Inngest steps are executed, check the ["How Inngest functions are executed"](/docs/learn/how-functions-are-executed) page.

## Anatomy of an Inngest function

Let's have a look at the following Inngest function:

```ts
import { inngest } from "./client";

export default inngest.createFunction(
    // config
  { id: "import-product-images" },
    // trigger (event or cron)
  { event: "shop/product.imported" },
    // handler function
    async ({ event, step }) => {
      // here goes the business logic
      return copyAllImagesToS3(event.data.imageURLs);
      // if you need to perform more than one task,
      // wrap each one in step.run()
    };
);
```

The above code can be translated as:

> This Inngest function is called `import-product-images`. When an event called `shop/product.imported` is received, run a function called `copyAllImagesToS3`.

Let's have a look at each of this function's components.

<Callout>
ðŸ’¡ You can test Inngest functions using standard tooling such as Jest or Mocha. To do so, export the job code and run standard unit tests.
</Callout>

### Config

The first parameter of the `createFunction` method specifies Inngest function's configuration. In the above example, the `id` is specified, which is a unique identifier for the function. It is the only required parameter of the configuration.

You can also provide other [configuration options](/docs/reference/functions/create#configuration), such as `concurrency`, `throttle`, `debounce`, `rateLimit`, `priority`, `batchEvents`, or `idempotency` (preventing duplicate events from triggering the function within 24 hours). You can also specify how many times the function will retry, what callback function will run on failure, and when to cancel the function.

### Trigger

Inngest functions are designed to be triggered by events or crons (schedules). Events can come from various sources like HTTP requests, your own code, or external webhooks. When an event is received, it triggers a corresponding function to execute the tasks defined in the function handler (see the ["Handler" section](/docs/functions/overview#handler) below).

Each function needs at least one trigger. However, you can also work with [multiple triggers](/docs/guides/multiple-triggers) to invoke your function whenever any of the events or crons is received.

### Handler

A "handler" is the core function that defines what should happen when the function is triggered. In the example above, the handler contains only one function called `copyAllImagesToS3`.

Handler receives context, which includes the event data (like `event.data.imageURLs` in the example above), logging configuration, and tools for managing execution flow (such as `step.run`, `step.sleep()`, or `step.waitForEvent()`.)

<Callout>
   ðŸ’¡ If your handler contains numerous functions, it is a good practice to wrap each one in a step. In this way, you can manage complex state easier and if any task fails, it will be retried independently from others.
</Callout>

To summarize, the handler allows you to define detailed logic that should happen in response to the triggering event.

## Kinds of Inngest functions

### <a href="/docs/guides/background-jobs" className="flex items-center gap-4"><IconConcurrency size="2rem"/> Background functions</a> {{anchor: false}}

Long tasks can be executed outside the critical path of the main flow, which improves app's performance and reliability. Perfect for data pipelines or data processing.

### <a href="/docs/guides/scheduled-functions" className="flex items-center gap-4"><IconConcurrency size="2rem"/> Scheduled functions</a> {{anchor: false}}

Inngest's scheduled functions enable you to run tasks automatically at specified intervals using cron schedules. These functions ensure consistent and timely execution without manual intervention. Perfect for routine operations like sending weekly reports or clearing caches.

### <a href="/docs/guides/delayed-functions" className="flex items-center gap-4"><IconConcurrency size="2rem"/> Delayed functions</a> {{anchor: false}}

You can equeue an Inngest function to run at a specific time in the future. The task will be executed exactly when needed without manual intervention. Perfect for actions like sending follow-up emails or processing delayed orders.

### <a href="/docs/guides/multi-step-functions" className="flex items-center gap-4"><IconConcurrency size="2rem"/> Multi-step functions</a> {{anchor: false}}

Multi-step functions allow you to create complex workflows. You can coordinate between multiple steps, including waiting for other events, delaying execution, or running code conditionally based on previous steps or incoming events. Each step is individually retriable, making the workflow robust against failures. Ideal for scenarios like onboarding flows or conditional notifications.

### <a href="/docs/guides/fan-out-jobs" className="flex items-center gap-4"><IconConcurrency size="2rem"/> Fan-out functions</a> {{anchor: false}}

Inngest's fan-out jobs enable a single event to trigger multiple functions simultaneously. Ideal for parallel processing tasks, like sending notifications to multiple services or processing data across different systems.

## Invoking functions directly

You can [call an Inngest function directly](/docs/guides/invoking-functions-directly) from within your event-driven system by using `step.invoke()`, even across different Inngest SDKs.

This is useful when you need to break down complex workflows into simpler, manageable parts or when you want to leverage existing functionality without duplicating code. Direct invocation is ideal for orchestrating dependent tasks, handling complex business logic, or improving code maintainability and readability.

## Further reading

- ["How Inngest functions are executed"](/docs/learn/how-functions-are-executed): Learn more about Inngest's execution model, including how steps are handled.