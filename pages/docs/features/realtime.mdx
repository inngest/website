import {
  RiNextjsFill,
  RiNodejsFill,
} from "@remixicon/react";
import { Info, CodeGroup, Steps, Step, CardGroup, Card, VersionBadge, GuideSelector, GuideSection } from "src/shared/Docs/mdx";

export const description = 'Learn how to use realtime to stream data from Inngest functions to your users.';

# Realtime <VersionBadge version="TypeScript SDK v3.32.0+" /> <VersionBadge version="Go SDK v0.9.0+" /> <VersionBadge version="Python v0.5.9+" />

<Info>
  Realtime is currently in developer preview. Some details including APIs are still subject to change during this period. Read more about the [developer preview here](#developer-preview).
</Info>

Realtime enables you to stream updates from your Inngest functions to your users, power live UIs, and implement bi-directional workflows such as Human-in-the-Loop.

Realtime user experience is a core requirement for any web application, especially when long-running tasks are involved. This is supported natively in Inngest without any additional infrastructure or configuration. Inngest manages the WebSocket server and the connection to your users.

## Concepts

There are two core parts of Realtime: **publishing** and **[subscribing](/docs/features/realtime/subscribe)**. You **publish** data from your functions and **subscribe** to data in your application, either browser or server.

Publishing data is done using the `publish()` function and has three components:

* `channel` - A namespace for which data belongs to, e.g., `user:123`. This is helpful to segment data to ensure that users only receive data that they are authorized to see.
* `topic` - A category of data within a `channel`, e.g., `llm_text_stream` or `upload_progress`. This is helpful to differentiate between types of data that you might use in different parts of your application.
* `data` - The data to be published to the realtime stream.

## Quick start

In this guide, we'll cover how to use realtime with our TypeScript SDK, subscribing from the client (browser). Start by installing the `@inngest/realtime` package:

<GuideSelector
  options={[
    { key: "typescript", title: "TypeScript" },
    { key: "python", title: "Python" },
  ]}
>

<GuideSection show="typescript">

<CodeGroup>
```shell {{ title: "npm" }}
npm install @inngest/realtime
```
```shell {{ title: "yarn" }}
yarn add @inngest/realtime
```
```shell {{ title: "pnpm" }}
pnpm add @inngest/realtime
```
```shell {{ title: "Bun" }}
bun add @inngest/realtime
```
```shell {{ title: "Deno" }}
deno add jsr:@inngest/realtime
```
</CodeGroup>
</GuideSection>

<GuideSection show="python">
```shell {{ title: "Python" }}
pip install inngest
```
</GuideSection>




<GuideSection show="typescript">
  <Info>
    This guide requires `@inngest/realtime` version `0.4.0` or higher.
  </Info>
</GuideSection>

<GuideSection show="python">
  <Info>
    This guide requires `inngest` version `0.5.9` or higher.
  </Info>
</GuideSection>



### Publishing

To publish data from your Inngest functions, you'll need to add the `realtimeMiddleware()` to your Inngest client. This will automatically add the `publish()` function to your Inngest functions.

<GuideSection show="typescript">
```ts {{ title: "client.ts" }}
import { Inngest } from "inngest";
// ℹ️ Import the middleware from the middleware sub-package:
import { realtimeMiddleware } from "@inngest/realtime/middleware";

export const inngest = new Inngest({
  id: "my-app",
  middleware: [realtimeMiddleware()],
});
```

Now, in your Inngest functions, the `publish()` function will be available as a parameter to your handler function. When publishing data, you'll need to specify the `channel` and `topic` you want to publish to and any data you want to publish.

</GuideSection>

<GuideSection show="python">

```py {{ title: "client.py" }}
import logging

import inngest

logger = logging.getLogger("uvicorn.inngest")
logger.setLevel(logging.DEBUG)

inngest_client = inngest.Inngest(app_id="fast_api_example", logger=logger)
```
</GuideSection>

<GuideSection show="typescript">

<CodeGroup>
```tsx {{ title: "Basic (untyped)" }}
import { inngest } from "./client";

inngest.createFunction(
  { id: "create-recommendation" },
  { event: "ai/recommendation.requested" },
  async ({ event, step, publish }) => {

    const response = await step.run('generate-response', () => {
      return llm.generateResponse(event.data.prompt);
    });

    // Publish data to a user-specific channel, on the "ai" topic.
    await publish({
      channel: `user:${event.data.userId}`,
      topic: "ai",
      data: {
        response: response,
        success: true,
      },
    });
    // ℹ️ Want type-safety with channels and topics? See the typed channels tab above.
  }
);

```
```tsx {{ title: "Typed channels (recommended)" }}
import { inngest } from "./client";
import { channel, topic } from "@inngest/realtime";

// Use the "channel" and "topic" functions to create helpers to
// add type-safety when using realtime:

// The "channel" builder function can accept a string as a channel name,
// or a function that returns a string. Here we create a channel for all logs:
const logsChannel = channel("logs").addTopic(topic("info").type<string>());

// Here we create a channel using the function pattern, which allows us to pass
// a parameter to the channel name. Here we create a channel for each user:
// The "topic" builder function can accept a schema or a type
const userChannel = channel((userId: string) => `user:${userId}`)
  // Add a specific topic, eg. "ai" for all AI data within the user's channel
  .addTopic(
    topic("ai").schema(
      z.object({
        response: z.string(),
        // Transforms are supported for realtime data
        success: z.number().transform(Boolean),
      })
    )
  );

inngest.createFunction(
  { id: "create-recommendation" },
  { event: "ai/recommendation.requested" },
  async ({ event, step, publish }) => {

    const response = await step.run('generate-response', () => {
      return llm.generateResponse(event.data.prompt);
    });

    // Publish data to a user-specific channel, on the "ai" topic.
    await publish(
      userChannel(event.data.userId).ai({
        response: response,
        success: true,
      })
    );

    await publish(logsChannel().info("All went well"));
  }
);
```
</CodeGroup>

</GuideSection>

<GuideSection show="python">

```py {{ title: "Python" }}
import inngest
from inngest.experimental import realtime

from .client import inngest_client


@inngest_client.create_function(
    fn_id="python-realtime-publish",
    trigger=inngest.TriggerEvent(event="realtime.test"),
)
async def python_realtime_publish(ctx: inngest.Context) -> str:
    async def my_first_step() -> dict[str, str]:
        return {"message": "My llm response from python!"}

    result = await ctx.step.run("my-first-step", my_first_step)

    await realtime.publish(
        client=inngest_client,
        channel="user:user_123456789",
        topic="messages",
        data=result,
    )

    return "Hello world!"
```
</GuideSection>

</GuideSelector>

{/* TODO - More on channels and topics, perhaps in a new page? */}


{/*

### Channels

Channels are environment-level containers that group one or more topics of data. You can create as many channels as you need. Some tips:

- You can subscribe to a channel before any data is published
- You can create a channel for a specific run ID, e.g., for a run's status: `run:${ctx.runId}`
- You can create channels for each user, or for a given conversation

### Topics

Topics allow you to specify individual streams within a channel. For example, within a given run you may publish status updates, AI responses, and tool outputs to a user.

Benefits of separating data by topics include:

- **Typing and data handling**: You can switch on the topic name to properly type and handle different streams of data within a channel.
- **Security**: You must specify topics when creating subscription tokens, allowing you to protect or hide specific published data.

### Subscription Tokens

Subscription tokens allow you to subscribe to the specified channel's topics. Tokens expire 1 minute after creation for security purposes. Once connected, you do not need to manage authentication or re-issue tokens to keep the connection active.

*/}

## Guides

Explore guides for using realtime with different frameworks and patterns:

<CardGroup cols={2}>

  <Card
    href="/docs/features/realtime/react-hooks"
    title={"Use Realtime React hooks in Next.js"}
    icon={<RiNextjsFill className="text-basis h-8 w-8"/>}
    iconPlacement="top"
  >
   Leverage the `useInngestSubscription()` hook to subscribe to realtime streams in your Next.js application.
  </Card>

  <Card
    href="/docs/examples/realtime"
    title={"Explore patterns and examples"}
    icon={<RiNodejsFill className="text-basis h-8 w-8"/>}
    iconPlacement="top"
  >
   Use Realtime to stream updates from one or multiple Inngest functions, or to implement a Human-in-the-Loop mechanism.
  </Card>

</CardGroup>

## SDK Support

Realtime is supported in the following SDKs:

| SDK        | Publish | Subscribe | Version |
| ---------- | ------- | --------- | ------- |
| TypeScript | ✅      | ✅        | >=v3.32.0  |
| Golang     | ✅      | ✅        | >=v0.9.0  |
| Python     | ✅      | -       | >=v0.5.9  |

## Limitations

- The number of currently active topics depends on your Inngest plan
- Data sent is currently at-most-once and ephemeral
- The max message size is currently 512KB

## Developer preview

Realtime is available as a developer preview. During this period:

* This feature is **widely available** for all Inngest accounts.
* Some details including APIs and SDKs are subject to change based on user feedback.
* There is no additional cost to using realtime. Realtime will be available to all Inngest billing plans at general availability, but final pricing is not yet determined.

Read the [release phases](/docs/release-phases) for more details.

## Security

Realtime is secure by default. You can only subscribe to a channel's topics using time-sensitive tokens. The subscription token mechanism must be placed within your own protected API endpoints.

You must always specify the channel and topics when publishing data. This ensures that users can only access specific subsets of data within runs.

## Delivery guarantees

Message delivery is currently at-most-once. We recommend that your users subscribe to a channel's topics as you invoke runs or send events to ensure delivery of data within a topic.
