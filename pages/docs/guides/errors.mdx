# Error handling

Inngest functions are designed to handle failures gracefully and will automatically retry after a failure. This adds an immediate layer of durability to your code, ensuring it survives transient issues like network timeouts, outages, or database locks.

- **Automatic retries:** Functions are retried automatically upon failure
- **Configurable retry policies:** Tailor the retry behavior to suit your specific use case
- **Failure handlers:** Utilize `onFailure` to handle all retries failing
- **Step-level retries:** Each step within a function can have its own retry logic and be handled individually

## Types of failure

Inngest helps you handle both **errors** and **failures**, which are defined differently.

<Callout>
A function that defines no steps is treated as a function with a single step, where that step is the entire function's code.
</Callout>

An **error** causes a step to retry. Exhausting all retry attempts will cause that step to **fail**, which means the step will never be attempted again this run.

A **failed** step can be handled with native language features such as `try`/`catch`, but unhandled errors will cause the function to **fail**, meaning the run is marked as "Failed" in the Inngest UI and all future executions are canceled.

Let's look at how to use and configure these retries.

## Retries

In a basic Inngest function, a default configuration of 3 retries will be set. For the function below, if the database write fails then it'll be retried up to 3 times until it succeeds or runs out of attempts.

<CodeGroup>
```ts {{ title: "TypeScript" }}
inngest.createFunction(
  { id: "click-recorder" },
  { event: "app/button.clicked" },
  async ({ event, attempt }) => {
    await db.clicks.insertOne(event.data); // this code now retries!
  },
);
```
```go {{ title: "Go" }}

```
```py {{ title: "Python" }}

```
</CodeGroup>

Notice that an `attempt` count is passed to the function, which is the current zero-based attempt number for this run. The first attempt will be `0`, the second `1`, and so on. It is incremented every time the function throws an error and is retried.

You can configure the number of retries by specifying it in your function configuration, including setting it to `0` to disable them:

<CodeGroup>
```ts {{ title: "TypeScript" }}
inngest.createFunction(
  {
    id: "click-recorder",
    retries: 10, // choose how many retries you'd like
  },
  { event: "app/button.clicked" },
  async () => { /* ... */ },
);
```
```go {{ title: "Go" }}

```
```py {{ title: "Python" }}

```
</CodeGroup>

## Steps

A function can be broken down into multiple steps, where each step is individually executed and retried.

Here, both the "_Get data_" and "_Save data_" steps have their own set of retries. If the "_Save data_" step has a failure, it's retried, alone, in a separate request.

<CodeGroup>
```ts {{ title: "TypeScript" }}
inngest.createFunction(
  { id: "sync-systems" },
  { event: "auto/sync.request" },
  async ({ step }) => {
    // Can be retried up to 3 times
    const data = await step.run("Get data", async () => {
      return getDataFromExternalSource();
    });

    // Can also be retried up to 3 times
    await step.run("Save data", async () => {
      return db.syncs.insertOne(data);
    });
  },
);
```
```go {{ title: "Go" }}

```
```py {{ title: "Python" }}

```
</CodeGroup>

### Handling a failing step

Unlike an error being thrown in the main function's body, a failing step (one that has exhausted all retries) will throw a `StepError`. This allows you to handle failures for each step indiviudally, where you can recover from the error gracefully.

If a step failure isn't handled, the error will bubble up to the function itself, which will then be marked as failed.

Here attempt to use DALL-E to generate an image from a prompt, but fall back to Midjourney if it fails. Remember that these calls are split over separate requests, making the code much more durable against timeouts, transient errors, and these depenencies on external APIs.

<CodeGroup>
```ts {{ title: "TypeScript" }}
inngest.createFunction(
  { id: "generate-result" },
  { event: "prompt.created" },
  async ({ event, step }) => {
    // try one AI model, if it fails, try another
    let imageURL: string | null = null;
    let via: "dall-e" | "midjourney";

    try {
      imageURL = await step.run("generate-image-dall-e", () => {
        // open api call to generate image...
      });
      via = "dall-e";
    } catch (err) {
      imageURL = await step.run("generate-image-midjourney", () => {
        // midjourney call to generate image...
      });
      via = "midjourney";
    }

    await step.run("notify-user", () => {
      return pusher.trigger(event.data.channelID, "image-result", {
        imageURL,
        via,
      });
    });
  },
);
```
```go {{ title: "Go" }}

```
```py {{ title: "Python" }}

```
</CodeGroup>

### Simple rollbacks

With this pattern, it's possible to assign a small rollback for each step, making sure that every action is safe regardless of how many steps are being run.

<CodeGroup>
```ts {{ title: "TypeScript" }}
inngest.createFunction(
  { id: "add-data" },
  { event: "app/row.data.added" },
  async ({ event, step }) => {
    // ignore the error - this step is fine if it fails
    await step
      .run("Non-critical step", () => {
        return updateMetric();
      })
      .catch();

    // Add a rollback to a step
    await step
      .run("Create row", async () => {
        const row = await createRow(event.data.rowId);
        await addDetail(event.data.entry);
      })
      .catch((err) =>
        step.run("Rollback row creation", async () => {
          await removeRow(event.data.rowId);
        }),
      );
  },
);
```
```go {{ title: "Go" }}

```
```py {{ title: "Python" }}

```
</CodeGroup>

## Failure handlers

If your function exhausts all of its retries, it will be marked as "Failed." You can handle this circumstance by providing an `onFailure` handler when defining your function.

Here we attempt to check a user's susbcription is valid a total of 6 times. If we can't check the subscription after all retries, we unsubscribe the user:

<CodeGroup>
```ts {{ title: "TypeScript" }}
inngest.createFunction(
  {
    id: "update-subscription",
    retries: 5,
    onFailure: async ({ event, error }) => {
      // if the susbcription check fails after all retries, unsubscribe the user
      await unsubscribeUser(event.data.userId);
    },
  },
  { event: "user/subscription.check" },
  async ({ event }) => { /* ... */ },
);
```
```go {{ title: "Go" }}

```
```py {{ title: "Python" }}

```
</CodeGroup>

Internally, this handler creates a second function that listens for the `inngest/function.failed` event, which you can listen to yourself to capture all failed runs across your system.

<CodeGroup>
```ts {{ title: "TypeScript" }}
inngest.createFunction(
  { id: "handle-any-fn-failure" },
  { event: "inngest/function.failed" },
  async ({ event }) => { /* ... */ },
);
```
```go {{ title: "Go" }}

```
```py {{ title: "Python" }}

```
</CodeGroup>

## Non-retriable errors

You can throw a non-retriable error from a step or a function, which will bypass any remaining retries and fail the step or function it was thrown from.

This is really useful for when you know an error is permanent and want to stop all execution. In this example, we know the user doesn't exist, so we'll stop trying to email them.

<CodeGroup>
```ts {{ title: "TypeScript" }}
inngest.createFunction(
  { id: "user-weekly-digest" },
  { event: "user/weekly-digest-requested" },
  async ({ event, step }) => {
    const user = await step
      .run("Get user email", () => {
        return db.users.findOne(event.data.userId);
      })
      .catch((err) => {
        if (err.name === "UserNotFoundError") {
          throw NonRetriableError("User no longer exists; stopping");
        }

        throw err;
      });

    await step.run("Send digest", () => {
      return sendDigest(user.email);
    });
  },
);
```
```go {{ title: "Go" }}

```
```py {{ title: "Python" }}

```
</CodeGroup>

## Delaying retries

Retries are executed with exponential back-off with some jitter, but it's also possible to specify exactly when you'd like a step or function to be retried.

In this example, an external API has informed us when we can make requests again using a `Retry-After` header, so we'll tell Inngest to retry our function then.

<CodeGroup>
```ts {{ title: "TypeScript" }}
inngest.createFunction(
  { id: "send-welcome-notification" },
  { event: "user/signed-up" },
  async ({ event, step }) => {
    const { success, retryAfter } = await twilio.messages.create({
      to: event.data.user.phoneNumber,
      body: "Welcome to our service!",
    });

    if (!success && retryAfter) {
      throw new RetryAfterError("Hit Twilio rate limit", retryAfter);
    }
  },
);
```
```go {{ title: "Go" }}

```
```py {{ title: "Python" }}

```
</CodeGroup>
